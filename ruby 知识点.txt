GC 垃圾内存回收
  ruby 堆空间会维护一个对象池，ObjectSpace，使用的对象都是从这个池子里取出。

  1、内存垃圾回收方式
  1.1 标记清除
    原理： 从根对象开始，递归遍历所有根对象及其引用的对象，将有用的对象标记一下(修改RVALUE中的一个bit)。
    这个过程完成之后，就开始清除算法，将所有没有被标记为有用的对象全部回收。

    缺点：
      需要递归遍历根对象，如果根对象关联对象很多，那么需要判断栈溢出的情况，这增加了复杂度。
      需要将所有未被标记的对象清除后，程序才能继续执行,造成等待时间过长，导致程序中断

    优化：
      引入了延迟清除算法；即在标记完成后，不一次性清除所有无用的对象，分散到后面的操作中，减少中断时间

      非递归标记算法；标记过程中，会维护相应的bitmap，将对象是否有用的信息映射到bitmap中。
      在标记对象的时候，不会去修改对象的数据，只会修改bitmap，这样就只会触发复制bitmap的数据，不会影响到其他Ruby对象。

  1.2 分代 GC
    原理：区别对待长期存在和短期存在的对象。标记过程会被分成两种，次标记(minor marking)针对短期对象，和主标记(Major marking)针对所有对象。

    缺点：当新的对象被老年对象引用时，上面的工作方式会导致被老年对象引用的新对象被回收

    优化：写屏障技术 当新对象被老年对象引用时，会将新对象追加到一个remembered set中，次标记每次会去遍历这个set，让对应拥有写屏障的新对象保持存活。

  1.3 增量 GC
    原理：由于主标记会一次遍历所有对象，在执行时会有较长的暂停，增量 GC 会将主标记拆分为数个小任务，分散执行，缩短单次执行时间

    缺点：在所有小标记任务未全部完成期间，如果有新的对象被创建了，而这个新对象又恰好被已经标记过的根对象引用了，那么这个新对象不会被标记为有用，在清除阶段就会被处理掉，这会引发严重问题。

    优化：增量GC用了三色及写屏障的巧妙算法解决了分批执行带来的这一问题